// initialize a JavaScript Virtual Machine
vmT := qjsVm()

// run a piece of JavaScript code, and return the last evaluation
rs := vmT.run(`
let a = 1.2

var b = a * 2.7

b
`)

// get and output the return result
pl("result: %v", rs)

// set a global value
vmT.set("c", "abc")

// eval is equivalent to run
rs2 := vmT.eval(`let d = "" + b + c; d`)

pl("result2: %v", rs2)

// get global variables' value from the VM
value_a := vmT.get("a") // 'a' is not accessible since the 'let'

pl("value a: %v(%v)", value_a, typeOf(value_a))

value_b := vmT.get("b") // 'b' is accessible by the 'var' keyword

pl("value b: %v(%v)", value_b, typeOf(value_b))

value_c := vmT.get("c") // 'c' is accessible, which is set by VM.set method

pl("value c: %v(%v)", value_c, typeOf(value_c))

// set a function/delegate/callback with parameters, then call it
sourceT := `
param ...vargs

global inputG

pln(inputG, vargs)

return vargs[0] + vargs[1] + inputG[0]
`

d1 := delegate(sourceT)

d1c := d1.compile(vmT.get("b")) // pass another parameter(via global variable inputG which will be an array)

vmT.setFunc("f1", d1c)

rs3 := vmT.run(`let d3 = f1(3, 5); d3`)

pl("result3: %v", rs3)

// should close VM after use
vmT.close()

// es6/es2015 features

vm2 := qjsVm()

pl("es6/es2015 result: %v", vm2.run(`const multiply = (x, y) => x * y;
multiply(2, 3); // 6`))

// es2023

pl("es2023 result: %v", vm2.run(`const isOdd = (number) => number % 2 === 1;
const numbers = [1, 2, 3, 4, 5];

numbers.findLast(isOdd) + numbers.findLastIndex(isOdd); // 5 + 4 = 9`))

vm2.close()

// promise, not supported

vm3 := qjsVm()

pl("promise result: %v", vm3.run(`

a = 0;

let response1 = await fetch('https://api.example.com/data1');
a = await response1.text();

a


`))

vm3.close()

